package sessions

import (
	"net/http"
	"fmt"
	"github.com/gin-gonic/gin"
)



const (
	// DefaultKey  = "github.com/gin-contrib/sessions"
	DefaultRegistryKey  = "github.com/qiujinwu/registrys"
	errorFormat = "[sessions] ERROR! %s\n"
	// Default flashes key.
	flashesKey = "_flash"
)

// NewSession is called by session stores to create a new session instance.
func NewSession(store Store, name string) *SessionImp {
	return &SessionImp{
			ID:"",
			name:name,
			store:store,
			written:false,
			Values: make(map[interface{}]interface{}),
			Options:nil,
			IsNew: true,
	}
}

type SessionImp struct {
	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string

	name    string
	//
	//request *http.Request
	//writer  http.ResponseWriter
	c *gin.Context

	store   Store
	written bool

	// Values contains the user-data for the session.
	Values  map[interface{}]interface{}
	Options *Options
	IsNew   bool
}

func (s *SessionImp) Get(key interface{}) interface{} {
	return s.Values[key]
}

func (s *SessionImp) Set(key interface{}, val interface{}) {
	s.Values[key] = val
	s.written = true
}

func (s *SessionImp) Delete(key interface{}) {
	delete(s.Values, key)
	s.written = true
}

func (s *SessionImp) Clear() {
	for key := range s.Values {
		s.Delete(key)
	}
}

func (s *SessionImp) AddFlash(value interface{}, vars ...string) {
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	var flashes []interface{}
	if v, ok := s.Values[key]; ok {
		flashes = v.([]interface{})
	}
	s.Values[key] = append(flashes, value)
	s.written = true
}

func (s *SessionImp) Flashes(vars ...string) []interface{} {
	s.written = true
	var flashes []interface{}
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	if v, ok := s.Values[key]; ok {
		// Drop the flashes and return it.
		delete(s.Values, key)
		flashes = v.([]interface{})
	}
	return flashes
}

//func (s *SessionImp) Options(options Options) {
//	s.Options = options
//}

func (s *SessionImp) Save() error {
	if s.Written() {
		e := s.store.Save(s.c, s)
		if e == nil {
			s.written = false
		}
		return e
	}
	return nil
}

func (s *SessionImp) Written() bool {
	return s.written
}


// shortcut to get session
//func Default(c *gin.Context) Session {
//	return c.MustGet(DefaultKey).(Session)
//}


// sessionInfo stores a session tracked by the registry.
type sessionInfo struct {
	s *SessionImp
	e error
}

func GetRegistry(c *gin.Context) *Registry {
	registry,exists := c.Get(DefaultRegistryKey)
	if exists && registry != nil {
		return registry.(*Registry)
	}
	newRegistry := &Registry{
		c:  c,
		sessions: make(map[string]sessionInfo),
	}
	c.Set(DefaultRegistryKey, newRegistry)
	return newRegistry
}

// Registry stores sessions used during a request.
type Registry struct {
	c *gin.Context
	sessions map[string]sessionInfo
}

// Get registers and returns a session for the given name and session store.
//
// It returns a new session if there are no sessions registered for the name.
func (s *Registry) Get(store Store, name string) (session *SessionImp, err error) {
	if !isCookieNameValid(name) {
		return nil, fmt.Errorf("sessions: invalid character in cookie name: %s", name)
	}
	if info, ok := s.sessions[name]; ok {
		session, err = info.s, info.e
	} else {
		var nsession Session
		nsession, err = store.New(s.c, name)
		session,ok = nsession.(*SessionImp)
		session.name = name
		session.c = s.c
		s.sessions[name] = sessionInfo{s: session, e: err}
	}
	session.store = store
	return
}

// Save saves all sessions registered for the current request.
func (s *Registry) Save(w http.ResponseWriter) error {
	var errMulti MultiError
	for name, info := range s.sessions {
		session := info.s
		if session.store == nil {
			errMulti = append(errMulti, fmt.Errorf(
				"sessions: missing store for session %q", name))
		} else if err := session.store.Save(s.c,session); err != nil {
			errMulti = append(errMulti, fmt.Errorf(
				"sessions: error saving session %q -- %v", name, err))
		}
	}
	if errMulti != nil {
		return errMulti
	}
	return nil
}


// Error ----------------------------------------------------------------------

// MultiError stores multiple errors.
//
// Borrowed from the App Engine SDK.
type MultiError []error

func (m MultiError) Error() string {
	s, n := "", 0
	for _, e := range m {
		if e != nil {
			if n == 0 {
				s = e.Error()
			}
			n++
		}
	}
	switch n {
	case 0:
		return "(0 errors)"
	case 1:
		return s
	case 2:
		return s + " (and 1 other error)"
	}
	return fmt.Sprintf("%s (and %d other errors)", s, n-1)
}
